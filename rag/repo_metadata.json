[
  {
    "path": "Adapter/adapterex.py",
    "type": "source",
    "tech_credit": "Adapter Pattern",
    "tech_credit_description": "Convert the interface of an existing class into another interface clients expect. Adapter allows classes with incompatible interfaces to work together, promoting system flexibility and reducing the cost of integration with third-party or legacy components."
  },
  {
    "path": "ADRs/api-with-abstraction-usecase",
    "type": "source",
    "tech_credit": "Architecture Design Records",
    "tech_credit_description": "Document architectural decisions in a lightweight, structured format to improve traceability, promote team alignment, and support future system evolution. ADRs capture the rationale, context, and alternatives behind design choices, enabling resilient and maintainable architecture."
  },
  {
    "path": "ADRs/configuration-management-usecase",
    "type": "source",
    "tech_credit": "Architecture Design Records",
    "tech_credit_description": "Document architectural decisions in a lightweight, structured format to improve traceability, promote team alignment, and support future system evolution. ADRs capture the rationale, context, and alternatives behind design choices, enabling resilient and maintainable architecture."
  },
  {
    "path": "ADRs/sql-in-dev-usecase",
    "type": "source",
    "tech_credit": "Architecture Design Records",
    "tech_credit_description": "Document architectural decisions in a lightweight, structured format to improve traceability, promote team alignment, and support future system evolution. ADRs capture the rationale, context, and alternatives behind design choices, enabling resilient and maintainable architecture."
  },
  {
    "path": "ArchitectureDesignRecords/Architecture_Design_Records_Ex",
    "type": "source",
    "tech_credit": "Architecture Design Records",
    "tech_credit_description": "Document architectural decisions in a lightweight, structured format to improve traceability, promote team alignment, and support future system evolution. ADRs capture the rationale, context, and alternatives behind design choices, enabling resilient and maintainable architecture."
  },
  {
    "path": "ChainOfResponsibility/chain_of_res_ex.py",
    "type": "source",
    "tech_credit": "Chain of responsibility",
    "tech_credit_description": "Avoid coupling the sender of a request to its receiver by giving more than one object a chance to handle the request. Chain the receiving objects and pass the request along the chain until an object handles it."
  },
  {
    "path": "CircuitBreaker/CircuitBreaker.py",
    "type": "source",
    "tech_credit": "Circuit Breaker",
    "tech_credit_description": "Enhance system resilience by dynamically detecting service failures and preventing cascading issues, especially in distributed systems."
  },
  {
    "path": "CircuitBreaker/PyCircuitBreaker.py",
    "type": "source",
    "tech_credit": "Circuit Breaker",
    "tech_credit_description": "Enhance system resilience by dynamically detecting service failures and preventing cascading issues, especially in distributed systems."
  },
  {
    "path": "Iterator/iter_ex.py",
    "type": "source",
    "tech_credit": "Iterator",
    "tech_credit_description": "Provide a way to access the elements of an aggregate object sequentially without exposing its underlying representation."
  },
  {
    "path": "MVC/controller.py",
    "type": "source",
    "tech_credit": "Model View Controller",
    "tech_credit_description": "Separate application concerns into three interconnected components: Model for business logic and data, View for user interface, and Controller for input handling. MVC promotes modularity, enabling independent development, testing, and reuse of each component."
  },
  {
    "path": "MVC/main.py",
    "type": "source",
    "tech_credit": "Model View Controller",
    "tech_credit_description": "Separate application concerns into three interconnected components: Model for business logic and data, View for user interface, and Controller for input handling. MVC promotes modularity, enabling independent development, testing, and reuse of each component."
  },
  {
    "path": "MVC/model.py",
    "type": "source",
    "tech_credit": "Model View Controller",
    "tech_credit_description": "Separate application concerns into three interconnected components: Model for business logic and data, View for user interface, and Controller for input handling. MVC promotes modularity, enabling independent development, testing, and reuse of each component."
  },
  {
    "path": "MVC/view.py",
    "type": "source",
    "tech_credit": "Model View Controller",
    "tech_credit_description": "Separate application concerns into three interconnected components: Model for business logic and data, View for user interface, and Controller for input handling. MVC promotes modularity, enabling independent development, testing, and reuse of each component."
  },
  {
    "path": "PlatformAbstractionLayers/BasicAbstractionPatternEx.py",
    "type": "source",
    "tech_credit": "Platform Abstraction Layers",
    "tech_credit_description": "Introduce intermediary layers that decouple application logic from third-party platforms, libraries, or APIs. This shields the core system from external changes, simplifies technology replacement, and reduces the cost and risk of platform evolution."
  },
  {
    "path": "Proxy/proxyex.py",
    "type": "source",
    "tech_credit": "Proxy",
    "tech_credit_description": "Provide a surrogate or placeholder for another object to control access to it."
  },
  {
    "path": "Strategy/strategyex.py",
    "type": "source",
    "tech_credit": "Strategy Pattern",
    "tech_credit_description": "Define a family of algorithms, encapsulate each one, and make them interchangeable. Strategy lets the algorithm vary independently from clients that use it."
  },
  {
    "path": "Template/templateex.py",
    "type": "source",
    "tech_credit": "Template method",
    "tech_credit_description": "Define the skeleton of an algorithm in an operation, deferring some steps to subclasses. Template method lets subclasses redefine certain steps of an algorithm without changing the algorithm's structure."
  },
  {
    "path": "Visitor/visitorex.py",
    "type": "source",
    "tech_credit": "Visitor Pattern",
    "tech_credit_description": "Represent an operation to be performed on instances of a set of classes. Visitor lets a new operation be defined without changing the classes of the elements on which it operates."
  }
]